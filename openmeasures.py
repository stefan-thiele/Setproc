"""
@uthor : Romain Vincent
Created 10/12/2010

This file contains the classes that handle the opening and saving of the measures.All functions specific to this method should be defined in this file
"""


"""
This first class is a generique one and it makes sure that all the opening method handle the common operations (such as saving) in the same manners
"""
class Measure(dict) :
	"""
	This allows to parse a json file and generate a python object from it. The argument to be given is the filename of the json file. The function returns the data in a python object format.
	"""
	################################
	def __init__(self,filename,mode) :
		dict.__init__(self)
		if mode == "Json" :
			temp = OpenJson(filename)
		elif mode == "Bin" :
			temp = OpenBin(filename)
		for x in temp :
			self[x] = temp[x]
		

	def save(self,savename) :
		"""
		Save all the keys field of a dictionnary in savename file. The "*.bin" extension should be used
		"""
		done = True
		try :
			stream = open(savename,"w")
		except IOError :
			print "Problem while saving the file"
			done = False
		l =[]
		temp = self.keys()
		l.append(temp) # this will be used when loading the file to set the keys of the dictionnary created
		for x in self:
			l.append(self[x])
		cPickle.dump(l,stream,1)

		return done


"""
This class is derived from the OpenMeasure class. It is specific to the json file data.
"""

class OpenJson(dict): 
	"""
	This allows to parse a json file and generate a python object from it. The argument to be given is the filename of the json file. The function returns the data in a python object format.
	"""
	def __init__(self,filename) :
		dict.__init__(self)
		state = self.load_json(filename)
	
	def load_json(self,filename,kind = "cyc") :
		"""
		This function choose the good parser by reading the "kind" field contained in the metadata. If not it asks you the information if not given
		"""
		done = True
		try :
			monjson = get_json(filename)
			if(kind == None):
				kind = monjson["kind"]

		except IOError :
			print "Problem loading the file"
			done = False
		except KeyError:
			kind = input("There is no information concerning the kind of file. Could you provide it ?(cyc in case of statistic on one sweep and cyc_loc if the field has been swept back and forth around a specific position")
		if(done) :
			if kind == "cyc" : #this function will be soon deprecated
				done = self.load_cyc_stat(monjson)
			elif kind == "new": #this is the one that should always been used
				done = self.load_new(monjson)
			else :
				print "The kind ",kind, " is not recognized"
				while True :
					choice = input("would you try again ? ")
					if choice in('y','yes') :
						kind = input("Enter the kind of sweep :")
						done = self.load_json(filename,kind)
						break
					if choice in ('no','n'):
						print "Its your choice"
						done = False
						break
					
		return done

	def load_cyc_stat(self,monjson) :
		"""
		This function constructs the object given a Json file corresponding at many cycles. The corresponding kind of file is "cycle"
		"""
		done = True
		try :
			K = monjson.keys()
			K.pop(K.index("vim_modeline")) #eliminate vim mode parameter
			# the function json_data(json_object,i,j) return the jth column of the ith measurement of a json_object
			self["sweep_number"] = size(monjson["measures"])
			self["bias"] = json_data(monjson,0,1)
			self["data"] = []
			for i in range(self["sweep_number"]):
				self["data"].append(json_data(monjson,i,2))
			K.pop(K.index("measures"))
			if (size(K) > 0) :
				self["metadata"] = dict([])
				for x in K :
					self["metadata"][x]  = monjson[x]
		except KeyError :
			print "Problem while loading the file. If an object is howerver loaded, it can be incomplete"
			done = False

		return done


	def load_new(self,monjson) :
		"""
		This is the file loader that handles the json files generated by the nanoqt scripts of the new generation
		"""
		done = True
		K = monjson.keys()
		K.pop(K.index("vim_modeline")) #vim mode
		self["sweep_number"] = size(monjson["measures"])
		self["data"] = []
		nbr = -1
		sweep_keys = None
		try :
			for i in range(self["sweep_number"]) :
				type_of_sweep = monjson["measures"][i]["type"]
				if(type_of_sweep == "approach") :
					sweep_keys = [] #Create the dict for the current sweep
					sweep_keys.append(type_of_sweep)
					nbr = nbr +1
					self["data"].append(dict([]))
				if( sweep_keys.__contains__(type_of_sweep) == False) : 
					sweep_keys.append(type_of_sweep)
					self["data"][nbr][type_of_sweep] = dict([])
					self["data"][nbr][type_of_sweep]["info"] = dict([])
					self["data"][nbr][type_of_sweep]["info"]["try_nbr"] = 1 
				self["data"][nbr][type_of_sweep]["bias"] = []
				self["data"][nbr][type_of_sweep]["data"] = [] 
				self["data"][nbr][type_of_sweep]["bias"].append(json_data(monjson,i,1))
				self["data"][nbr][type_of_sweep]["data"].append(json_data(monjson,i,2))
				self["data"][nbr][type_of_sweep]["info"]["try_nbr"] += 1
		
			self["total_sweep"] = nbr 

		except KeyError : 
			print "Problem while loading data. If data have been loaded, they could be incomplete"
			done = False
		
		return done


class OpenBin(dict): 
	"""
	This class create an OpenBin object given a binary file generated from a measurement
	"""
	################################
	def __init__(self,filename) :
		dict.__init__(self)
		self.load_bin(filename)

	def load_bin(self,filename) :
		done = True
		try :
			stream = open(filename,"r")
		except IOError :
			print "Problem while loading the binary file. Check the file name and/or the folder"
			done = False

		temp = cPickle.load(stream)
		stream.close()
		X = temp[0]
		i=1
		for x in X :
			self[x] = temp[i]
			i+=1
		return done
