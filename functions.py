"""
@@@@@@@@@@@@@@@@@@@@@@@@@
This file contains all the functions needed for the different classes
@@@@@@@@@@@@@@@@@@@@@@@@@
"""


####################################
def get_json(filename) :
	"""
	Given a json filename, return the corresponding python object.
	"""
	result =  json.load(open(filename,'r'))
	return  result


####################################
def get_coupling():
	"""	
	This function gives the coupling of the sample to the gate source and drain as weel as the alpha factor given by Cg/Ct . 
	One has to give four point, starting with the slope defined by Cg/Cs and then the one defined by Cg / (Cd +Cg). It retunrs the result 
	as Cs Cd and alpha.
	"""
	temp = ginput(4)
	Cs = np.abs( (temp[0][0] - temp[1][0]) / (temp[0][1] - temp[1][1])) * 1e3
	tp = np.abs( ( temp[2][1] - temp[3][1] )/(temp[2][0] - temp[3][0])) * 1e-3
	Cd = (1 - tp)/ tp
	alp = 1 / (Cs + 1 +Cd)
	return [Cs,Cd,alp] 


####################################
def get_slope():
	"""
	Given two points, give the slope a line
	"""
	temp = ginput(2)
	return (temp[0][1] - temp[1][1])/(temp[0][0] - temp[1][0])



#####################################
def getposcolumn(data,string):
	"""
	This function allows to obtain the column number in a json file sweep given the name of the input
	"""
	result = 0
	for i in range(size(data["measures"][0]["columns"])) :
		if(data["measures"][0]["columns"][i] == string) :
			result = i+1
	return result

######################################
def json_data(jsonobject,i,column) :
	"""
	Given a json object generated by NanoQt, it extracts the column of a the data nbr i
	"""
	try :
		data_temp = jsonobject["measures"][i]["data"]
	except :
		print "Problem using data_json function"

	if type(column) == str:
		try :
			column = getposcolumn(data_temp,column)	
		except :
			print "There is not such a column name, taking column = 1"
			column = 1
	temp = []

	for j in range(len(data_temp)):
		temp.append(data_temp[j][column-1])

	return temp


######################################
def colarray(data, colnum, rem):
	"""
	This function give back the column of an array given the array and the column number to be extracted. 
	The third parameter allow to get ride of the first terms of the column.
	"""
	temp = []
	for i in range( len(data) - rem):
		temp.append(data[i+rem][colnum-1])
	return temp


######################################
def colarray_pol(data,A,B,theta):
	"""
	This function is dedicated to the polarplot in oder to take into account the signe of the magnetic field in the trace - retrace pot
	"""		
	temp = []
	for i in range( len(data)):
		temp.append(data[i][1] * sign(data[i][0]) - A*abs(sin(theta)) - B*abs(cos(theta)))
	return temp



#######################################
def plotdata(data, x, y):
	"""
	This function plot a 2D curve given a json data and the column number of x and y axis.
	"""
	plot(colarray(data, x, 0), colarray(data, y, 0))
	return True


########################################
def getinputs(data):
	"""
	This function give the inputs used for a measurement given the corresponding json file.
	"""
	inputs = data["inputs"]
	result = []
	for x in inputs:
		result.append(str(data["inputs"][x]["name"]).replace("u", ""))
	return result

########################################
def getoutputs(data):
	"""
	This function give the outputs used for a measurement given the corresponding json file.
	"""
	
	inputs = data["outputs"]
	result = []
	for x in inputs:
		result.append(str(data["outputs"][x]["name"]).replace("u", ""))
	return result

########################################
def getcolumns(data, col_num, sweep_num):
	"""
	This function allows to access to one column of a json file sweep given the sweep and the column numbers.
	"""
	result = []
	for i in range(sweep_num):
		result.append(colarray(data["measures"][i]["data"],col_num , 0))
	return result


"""

With the new json style, this function becomes useless
def get_GB(data, col_num, sweep_num):
This function allows to access to one column of a json file sweep given the sweep and the column numbers.
result = []
result.append(colarray(data["measures"][sweep_num]["data"],col_num , 0))
return result[0]
"""


#######################################
def export_data(filename, data):
	savetxt(filename,matrix(data).transpose(),delimiter = " , ")
	return True


#######################################
def extractScilab(data):
	"""
	This function allows to extract the data from a CSV like file. This is the function that should be used for the old transfrom data.
	"""
	
	raw = size(data) / size(data[1])
	result = []
	for i in range(raw-1) :
		result.append(data[ (i+1) , 1: ])
	return result


#######################################
def plot_profile_h(im):
	"""
	Given a point on the Coulomb Map, this function plot the corresponding profile and returns a array of two columns [V,dI/dV]
	"""
	y = ginput()[0][1]
	xm,  Xm = im.get_extent()[0:2]
	ym,  Ym = im.get_extent()[2:4]
	sweep_n = size(im.get_array()) / size(im.get_array()[0])
	nbr =  (1. * sweep_n / abs(Ym - ym)) * (y-ym) 
	figure()
	data = im.get_array()
	plot(linspace(xm, Xm, size(im.get_array()[0])) ,  data[nbr])
	return [linspace(xm, Xm, size(im.get_array()[0]))  , data[nbr]]



#######################################
def plot_profile(im):
	"""
	Given a point on the Coulomb Map, this function plot the corresponding profile and returns a array of two columns [V,dI/dV]
	"""
	x = ginput()[0][0]
	xm,  Xm = im.get_extent()[0:2]
	ym,  Ym = im.get_extent()[2:4]
	sweep_n = size(im.get_array()[0])
	nbr =  (1. * sweep_n / abs(Xm - xm)) * (x-xm)
	Vg = xm + nbr * (Xm-xm)/sweep_n 		
	figure()
	data = im.get_array()
	plot( linspace(ym, Ym, size(colarray(data,floor(nbr),0))) ,  colarray(data,floor(nbr),0))
	return [linspace(ym, Ym, size(colarray(data,floor(nbr),0))) ,  colarray(data,floor(nbr),0),Vg]


#######################################
def extract_pop(histo,nbr_pic,width) :
	result = []
	X = ginput(nbr_pic)
	size_hist = size(histo[1])
	Xmin = histo[1][0]
	Xmax = histo[1][-1]
	step = 1.0 * abs(Xmax-Xmin)/size_hist
	for i in range(nbr_pic) :
		center = floor(abs(X[i][0] - Xmin)/step)
		result.append(sum(histo[0][center-width:center+width]))
	return [result,1.0*array(result)/sum(result)]


#######################################
def plot_int(data):
	"""
	Given a array of data in the form [V, dI/dV], it comutes and plot the integral. This fonction can be used together with plot_profile
	to evaluate the gamma parameters of the sample.
	"""
	result = []
	for i in range(len(data[0])+1):
		if i > 0 :
			result.append(integrate.simps(data[0][0:i], data[1][0:i]))
	f=figure()
	result.reverse()
	vd =  array(data[1])
	vd = vd.tolist()
	vd.reverse()
	plot(vd, result)
	x= ginput()
	for i in range(len(result)) :
		result[i] = result[i] -x[0][1] 
	f.clear()
	plot(vd, result)
	return result


######################################
def co_above(data,seuil):
	data.sort(reverse = True)
	for i in range(size(data)):
		if data[i]< seuil :
			result = i
			break
	return result


#######################################
def sum_over(data) :
	result = []
	for i in range(len(data)) :
		result.append(sum(data[0:i+1]))
	
	return result


########################################
def merge_GB(GB_array) :
	GB_temp = deepcopy(GB_array[0])
	GB_nbr = size(GB_array)
	GB_order = range(1,GB_nbr,1)
	if( GB_nbr >1 ) :
		for i in GB_order :
			whole_size = size(GB_array[i]["data"])
			sweep_size = size(GB_array[i]["data"][1])
			current_array_size = whole_size/sweep_size
			for j in range(current_array_size) :
				GB_temp["data"].append(GB_array[i]["data"][j])
				GB_temp["date"].append(GB_array[i]["date"][j])
	GB_temp["sweep_number"] = len(GB_temp["data"])

	return GB_temp


#########################################
def check_span(X,Y,span):
	size_X = size(X)
	Xloc = list(X)
	Yloc = list(Y)
	to_delete = []
	for i in range(size_X) :
		for j in range(size_X) :
			if(abs(Xloc[i] - Xloc[j]) < span  and i != j) :
				if(Yloc[i] > Yloc[j]) :
					if to_delete.__contains__(j) == False :
						to_delete.append(j)
				else :	
					if to_delete.__contains__(i) == False :
						to_delete.append(i)
	to_delete = array(to_delete)
	to_delete.sort()
	si = size(to_delete)
	for i in range(si) :
		Xloc.pop(to_delete[si-i-1])
		Yloc.pop(to_delete[si-i-1])

	return [Xloc,Yloc] 


############################################
def max_local(X,Y,separation) :
	result = [[],[]]
	size_array = size(Y)
	for i in range(size_array) :
		if(i >0 and i < size_array-1 and (Y[i-1] < Y[i] and Y[i] > Y[i+1])) :
			result[0].append(X[i])
			result[1].append(Y[i])
	result = fct3.check_span(array(result[0]),array(result[1]),separation) 

	return result



############################################
def get_jump(X,Y,seuil,span) :
	jumps = max_local(X,Y,span)
	Xs = list(jumps[0])
	Ys = list(jumps[1])
	si_Ys = size(Ys)
	for i in range(si_Ys) :
		if(Ys[si_Ys - (i+1)] < seuil ) :
			Ys.pop(si_Ys - (i+1))
			Xs.pop(si_Ys - (i+1))
	return [Xs,Ys]


